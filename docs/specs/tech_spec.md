# tech_spec.md — Quizazz (SvelteKit + Node + Python)

## Overview

This document defines **how** Quizazz is built — architecture, module layout, dependencies, data models, and cross-cutting concerns. For requirements and behavior, see [`features.md`](features.md). For the phased implementation plan, see [`stories.md`](stories.md).

---

## Runtime & Tooling

| Concern | Choice | Notes |
|---------|--------|-------|
| **App framework** | SvelteKit 2.x | Static SPA via `@sveltejs/adapter-static` |
| **Language** | TypeScript 5.x | Strict mode enabled |
| **Styling** | Tailwind CSS 4.x | Utility-first; minimal custom CSS |
| **Component library** | None (hand-rolled) | Keep dependencies minimal; Lucide icons for iconography |
| **Client-side DB** | sql.js (WASM) | SQLite compiled to WASM, persisted to IndexedDB |
| **Build tool** | Vite (via SvelteKit) | Standard SvelteKit toolchain |
| **Python runtime** | Python 3.12+ | Used only in `builder/` for YAML validation/compilation |
| **Python package manager** | uv | Fast, modern Python package management |
| **Node package manager** | pnpm | Workspace-aware, fast |
| **Linter (JS/TS)** | ESLint + Prettier | SvelteKit defaults |
| **Linter (Python)** | Ruff | Fast, replaces flake8/isort/black |
| **Test runner (JS/TS)** | Vitest | Vite-native, fast |
| **Test runner (Python)** | pytest | Standard |

---

## Dependencies

### App Runtime Dependencies (`app/package.json`)

| Package | Purpose |
|---------|---------|
| `svelte` | UI framework |
| `@sveltejs/kit` | App framework |
| `@sveltejs/adapter-static` | Static site generation |
| `sql.js` | SQLite WASM for client-side database |
| `lucide-svelte` | Icon library |

### App Dev Dependencies (`app/package.json`)

| Package | Purpose |
|---------|---------|
| `typescript` | Type checking |
| `tailwindcss` | Utility CSS framework |
| `@tailwindcss/vite` | Tailwind Vite plugin |
| `vitest` | Unit/integration testing |
| `@testing-library/svelte` | Component testing utilities |
| `eslint` | Linting |
| `prettier` | Code formatting |
| `prettier-plugin-svelte` | Svelte formatting support |

### Builder Dependencies (`builder/pyproject.toml`)

| Package | Purpose |
|---------|---------|
| `pyyaml` | YAML parsing |
| `pydantic` | Data validation and schema enforcement |
| `pytest` | Testing |
| `ruff` | Linting and formatting |

---

## Repository Structure

```
quizazz/
├── LICENSE                          # Apache-2.0
├── README.md                        # Project overview, setup, usage
├── data/
│   └── questions/
│       └── sample.yaml              # Example question bank
├── app/
│   ├── package.json
│   ├── svelte.config.js
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── tailwind.config.ts
│   ├── static/
│   │   └── sql-wasm.wasm            # sql.js WASM binary (copied at build)
│   ├── src/
│   │   ├── app.html                 # SvelteKit shell
│   │   ├── app.css                  # Tailwind imports + global styles
│   │   ├── lib/
│   │   │   ├── data/
│   │   │   │   └── questions.json   # Compiled question bank (generated by builder)
│   │   │   ├── db/
│   │   │   │   ├── database.ts      # sql.js init, IndexedDB persistence, schema
│   │   │   │   └── scores.ts        # Score CRUD operations
│   │   │   ├── engine/
│   │   │   │   ├── selection.ts     # Weighted random question selection
│   │   │   │   ├── presentation.ts  # Answer selection and shuffling
│   │   │   │   └── scoring.ts       # Point calculation per answer category
│   │   │   ├── stores/
│   │   │   │   └── quiz.ts          # Svelte stores for quiz state
│   │   │   ├── types/
│   │   │   │   └── index.ts         # TypeScript type definitions
│   │   │   └── utils/
│   │   │       └── random.ts        # Shuffle and weighted random helpers
│   │   └── routes/
│   │       └── +page.svelte         # Single-page app (all views in one route)
│   └── tests/
│       ├── db/
│       │   └── scores.test.ts
│       ├── engine/
│       │   ├── selection.test.ts
│       │   ├── presentation.test.ts
│       │   └── scoring.test.ts
│       └── utils/
│           └── random.test.ts
├── builder/
│   ├── pyproject.toml
│   ├── src/
│   │   └── quizazz_builder/
│   │       ├── __init__.py
│   │       ├── __main__.py          # CLI entry point: python -m quizazz_builder
│   │       ├── models.py            # Pydantic models for question/answer schema
│   │       ├── validator.py         # YAML validation logic
│   │       └── compiler.py          # YAML → JSON compilation
│   └── tests/
│       ├── test_models.py
│       ├── test_validator.py
│       └── test_compiler.py
└── docs/
    ├── guides/
    │   └── project_guide.md
    └── specs/
        ├── features.md
        ├── tech_spec.md
        └── stories.md
```

---

## Key Component Design

### Builder: `quizazz_builder.models`

Pydantic models that define and validate the YAML schema.

```python
class Answer(BaseModel):
    text: str                    # Non-empty answer text
    explanation: str             # Non-empty explanation

class AnswerSet(BaseModel):
    correct: list[Answer]        # >= 1
    partially_correct: list[Answer]  # >= 1
    incorrect: list[Answer]      # >= 1
    ridiculous: list[Answer]     # >= 1

    @model_validator(mode="after")
    def check_minimum_total(self) -> "AnswerSet":
        """Total answers across all categories must be >= 5."""

class Question(BaseModel):
    question: str                # Non-empty question text
    answers: AnswerSet

class QuestionBank(RootModel):
    root: list[Question]         # The top-level YAML list
```

### Builder: `quizazz_builder.validator`

```python
def validate_file(path: Path) -> list[Question]:
    """Parse and validate a single YAML file. Raises ValidationError with
    file path, question index, and specific violation details."""

def validate_directory(directory: Path) -> list[Question]:
    """Validate all .yaml files in a directory. Returns the merged list
    of validated questions. Raises on first error."""
```

### Builder: `quizazz_builder.compiler`

```python
def compile_questions(questions: list[Question], output_path: Path) -> None:
    """Serialize validated questions to JSON. Each question gets a stable
    unique ID (SHA-256 hash of the question text) for database keying."""
```

### Builder: `quizazz_builder.__main__`

```python
# CLI: python -m quizazz_builder --input data/questions/ --output app/src/lib/data/questions.json
# Exit 0 on success, exit 1 with descriptive error on validation failure.
```

### App: `lib/types/index.ts`

```typescript
export type AnswerCategory = "correct" | "partially_correct" | "incorrect" | "ridiculous";

export interface Answer {
  text: string;
  explanation: string;
  category: AnswerCategory;
}

export interface Question {
  id: string;           // Stable hash from builder
  question: string;
  answers: Answer[];    // Flat list with category attached (from compiled JSON)
}

export interface QuizConfig {
  questionCount: number;
  answerCount: 3 | 4 | 5;
}

export interface PresentedAnswer extends Answer {
  label: string;        // "a", "b", "c", "d", "e"
}

export interface QuizQuestion {
  question: Question;
  presentedAnswers: PresentedAnswer[];
  selectedLabel: string | null;
  submittedLabel: string | null;
}

export interface QuizSession {
  config: QuizConfig;
  questions: QuizQuestion[];
  currentIndex: number;
  completed: boolean;
}

export interface QuestionScore {
  questionId: string;
  cumulativeScore: number;
}
```

### App: `lib/db/database.ts`

```typescript
import initSqlJs, { type Database } from "sql.js";

const DB_NAME = "quizazz";
const DB_STORE = "database";

export async function initDatabase(): Promise<Database> {
  /** Load sql.js WASM, restore DB from IndexedDB if available,
   *  otherwise create fresh schema. */
}

export async function persistDatabase(db: Database): Promise<void> {
  /** Export DB to Uint8Array and save to IndexedDB. */
}

export function createSchema(db: Database): void {
  /** CREATE TABLE IF NOT EXISTS question_scores (
   *    question_id TEXT PRIMARY KEY,
   *    cumulative_score INTEGER DEFAULT 0
   *  );
   *  CREATE TABLE IF NOT EXISTS session_answers (
   *    id INTEGER PRIMARY KEY AUTOINCREMENT,
   *    session_id TEXT,
   *    question_id TEXT,
   *    selected_category TEXT,
   *    points INTEGER,
   *    timestamp INTEGER
   *  ); */
}
```

### App: `lib/db/scores.ts`

```typescript
export function getScores(db: Database): QuestionScore[] {
  /** SELECT question_id, cumulative_score FROM question_scores */
}

export function updateScore(db: Database, questionId: string, points: number): void {
  /** UPDATE question_scores SET cumulative_score = cumulative_score + ? WHERE question_id = ? */
}

export function seedScores(db: Database, questionIds: string[]): void {
  /** INSERT OR IGNORE for each question ID with score 0. */
}

export function recordAnswer(
  db: Database, sessionId: string, questionId: string,
  category: AnswerCategory, points: number
): void {
  /** INSERT into session_answers. */
}
```

### App: `lib/engine/selection.ts`

```typescript
export function selectQuestions(
  questions: Question[],
  scores: QuestionScore[],
  count: number
): Question[] {
  /**
   * Weighted random selection without replacement.
   *
   * Weight formula: weight = max_score - score + 1
   *   where max_score = max(all cumulative scores)
   *   This ensures all weights are positive (minimum weight = 1).
   *
   * Algorithm:
   * 1. Compute weight for each question.
   * 2. Pick a random question proportional to weight.
   * 3. Remove it from the pool.
   * 4. Repeat until count is reached or pool is exhausted.
   */
}
```

### App: `lib/engine/presentation.ts`

```typescript
export function presentAnswers(
  question: Question,
  answerCount: 3 | 4 | 5
): PresentedAnswer[] {
  /**
   * 1. Pick one random answer from the "correct" category.
   * 2. Collect all non-correct answers into a pool.
   * 3. Randomly pick (answerCount - 1) from the pool.
   * 4. Combine, shuffle, and assign labels "a" through "e".
   */
}
```

### App: `lib/engine/scoring.ts`

```typescript
export const SCORE_MAP: Record<AnswerCategory, number> = {
  correct: 1,
  partially_correct: -2,
  incorrect: -5,
  ridiculous: -10,
};

export function scoreAnswer(category: AnswerCategory): number {
  return SCORE_MAP[category];
}
```

### App: `lib/stores/quiz.ts`

```typescript
import { writable, derived } from "svelte/store";

/** Reactive stores for the quiz lifecycle. */

export const quizSession = writable<QuizSession | null>(null);
export const viewMode = writable<"config" | "quiz" | "summary" | "review">("config");
export const reviewIndex = writable<number | null>(null);

export const currentQuestion = derived(quizSession, ($session) => {
  if (!$session) return null;
  return $session.questions[$session.currentIndex];
});

export const progress = derived(quizSession, ($session) => {
  if (!$session) return { current: 0, total: 0, percent: 0 };
  const answered = $session.questions.filter((q) => q.submittedLabel !== null).length;
  return {
    current: answered,
    total: $session.questions.length,
    percent: Math.round((answered / $session.questions.length) * 100),
  };
});
```

### App: `routes/+page.svelte`

Single-page app with four view states managed by the `viewMode` store:

| View | Component | Description |
|------|-----------|-------------|
| `config` | `ConfigView` | Question count slider, answer count radio, Start button |
| `quiz` | `QuizView` | Question display, answer selection, progress bar, Submit |
| `summary` | `SummaryView` | Score %, question list with ✓/✗, Retake/Start/Quit buttons |
| `review` | `ReviewView` | Single question detail with explanations, ← Back button |

All views are rendered inline in `+page.svelte` using conditional blocks (`{#if}`). No SvelteKit routing is used beyond the single page — all navigation is state-driven.

---

## Data Models

### Compiled JSON Format (output of builder)

```json
[
  {
    "id": "a1b2c3d4...",
    "question": "What is the capital of France?",
    "answers": [
      { "text": "Paris", "explanation": "Paris has been...", "category": "correct" },
      { "text": "Lyon", "explanation": "Lyon is the...", "category": "partially_correct" },
      { "text": "Berlin", "explanation": "Berlin is...", "category": "incorrect" },
      { "text": "Atlantis", "explanation": "Atlantis is...", "category": "ridiculous" },
      { "text": "The Moon", "explanation": "The Moon is...", "category": "ridiculous" }
    ]
  }
]
```

The builder flattens the categorized YAML structure into a flat answer list with an explicit `category` field. This simplifies the runtime code — no need to re-parse categories.

### SQLite Schema

```sql
CREATE TABLE IF NOT EXISTS question_scores (
  question_id   TEXT PRIMARY KEY,
  cumulative_score INTEGER NOT NULL DEFAULT 0
);

CREATE TABLE IF NOT EXISTS session_answers (
  id              INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id      TEXT NOT NULL,
  question_id     TEXT NOT NULL,
  selected_category TEXT NOT NULL,
  points          INTEGER NOT NULL,
  timestamp       INTEGER NOT NULL
);
```

`session_answers` stores individual answer records for potential future analytics. For v1, it is written to but only read during the current session (for the review screen). The `session_id` is a UUID generated when a quiz starts.

---

## Cross-Cutting Concerns

### Database Persistence Strategy

1. On app load: attempt to restore DB from IndexedDB.
2. If missing or corrupt: create fresh DB, create schema, seed scores from `questions.json`.
3. After each score update: persist DB to IndexedDB (debounced if needed, but given the low frequency of writes — one per question — immediate persistence is fine).
4. On retake/new quiz: no DB reset; scores accumulate across all sessions.

### Error Handling

| Layer | Strategy |
|-------|----------|
| Builder (Python) | Raise `SystemExit` with descriptive message on validation failure. Pydantic `ValidationError` provides field-level detail. |
| App build | If `questions.json` is missing or empty, Vite build fails (import error). |
| App runtime (DB) | Wrap sql.js operations in try/catch. On unrecoverable error, show a user-friendly error banner with a "Reset Database" option. |
| App runtime (UI) | Svelte error boundaries where applicable. Defensive checks on store state. |

### Keyboard Interaction Map

| Key | Context | Action |
|-----|---------|--------|
| `a`–`e` | Quiz view | Select corresponding answer |
| `Enter` | Quiz view (answer selected) | Submit answer |
| `Enter` | Config view (valid config) | Start quiz |
| `←` / `Backspace` | Review view | Return to summary |

### WASM Binary Handling

The `sql-wasm.wasm` file must be available at runtime. Strategy:
1. Copy `node_modules/sql.js/dist/sql-wasm.wasm` to `app/static/` during setup (npm postinstall script or manual).
2. Initialize sql.js with `locateFile: (file) => \`/${file}\`` so it loads from the static directory.

---

## Testing Strategy

### Python (builder)

| Test file | Covers |
|-----------|--------|
| `test_models.py` | Pydantic model validation: valid questions, missing fields, empty strings, insufficient answers, category constraints |
| `test_validator.py` | File-level validation: valid YAML, malformed YAML, missing files, empty files, multiple files in directory |
| `test_compiler.py` | JSON output: correct structure, stable IDs (hash consistency), category flattening |

### TypeScript (app)

| Test file | Covers |
|-----------|--------|
| `scores.test.ts` | Score CRUD: seed, update, get; cumulative behavior; missing question handling |
| `selection.test.ts` | Weighted selection: all questions selectable, lower scores favored (statistical test over N iterations), pool exhaustion |
| `presentation.test.ts` | Answer presentation: exactly 1 correct, correct total count, all labels assigned, shuffling |
| `scoring.test.ts` | Point values per category |
| `random.test.ts` | Shuffle uniformity, weighted random correctness |

UI/component tests are deferred to a later phase — the core logic is thoroughly unit-tested via the engine and db modules.
